;*********************************************************
;*  TAPE DRIVE EMULATOR FOR FPGA IMPLEMENTATION OF THE   *
;*  TRS80 MODEL MC-10 COMPUTER. DESIGNED FOR PIC16F747.  *
;*  ALL CODE WRITTEN BY STEVE L00SER-ROJAS               *
;*  SYSTEM CLOCK SHOULD BE 4 MHz.                        *
;*********************************************************

    LIST P=PIC16F747
    #INCLUDE <p16f747.inc>
    __CONFIG	_CONFIG1, _CP_OFF & _CCP2_RC1 & _DEBUG_OFF & _VBOR_2_7 & _BOREN_0 & _MCLR_ON & _PWRTE_ON & _WDT_OFF & _EXTCLK
    __CONFIG	_CONFIG2, _BORSEN_0 & _IESO_OFF & _FCMEN_OFF
    ORG 0x000

;PIN USAGE:
; PORTA,0 TXD (SOFTWARE UART) OUTPUT
; PORTA,1 RXD (SOFTWARE UART) INPUT
; PORTA,2 DISPLAY CE OUTPUT
; PORTA,3 DISPLAY RS OUTPUT
; PORTA,4 UNUSED (OPEN DRAIN) OUTPUT
; PORTA,5 UNUSED OUTPUT
; PORTA,6 CLOCK INPUT
; PORTA,7 CLOCK INPUT
; PORTB,0 CH376S INTERRUPT INPUT
; PORTB,1 TAPE INPUT
; PORTB,2 TAPE OUTPUT
; PORTB,3 BUTTON 1 INPUT
; PORTB,4 BUTTON 2 INPUT
; PORTB,5 BUTTON 3 INPUT
; PORTB,6 BUTTON 4 INPUT    ICSP CLOCK
; PORTB,7 RAM CE OUTPUT     ICSP DATA
; PORTC,0 UNUSED OUTPUT
; PORTC,1 UNUSED OUTPUT
; PORTC,2 UNUSED OUTPUT
; PORTC,3 SCK (HARDWARE SPI) OUTPUT
; PORTC,4 SDI (HARDWARE SPI) INPUT
; PORTC,5 SDO (HARDWARE SPI) OUTPUT
; PORTC,6 TXD (HARDWARE UART) INPUT (MUST BE CONFIGURED AS INPUT FOR UART MODULE TO WORK. THIS IS ACTUALLY AN OUTPUT)
; PORTC,7 RXD (HARDWARE UART) INPUT
; PORTD,0 UNUSED OUTPUT
; PORTD,1 UNUSED OUTPUT
; PORTD,2 CH376S CE OUTPUT
; PORTD,3 CH376S RESET OUTPUT
; PORTD,4 TEST OUTPUT
; PORTD,5 UNUSED OUTPUT
; PORTD,6 DISPLAY CLOCK OUTPUT
; PORTD,7 DISPLAY DATA OUTPUT
; PORTE,0 UNUSED OUTPUT
; PORTE,1 UNUSED OUTPUT
; PORTE,2 UNUSED OUTPUT

;REGISTER USAGE:
VARS    udata
DREG res 1	    ;USED TO STORE RECEIVED DATA, KB_SEND, KB_READ
TEMP1 RES 1	    ;USED FOR TEMPORARY STORAGE
TEMP2 RES 1
TEMP3 RES 1	    ;TEMPORARY VARIABLE FOR USE IN USER INTERFACE FUNCTIONS
TEMP4 RES 1	    ;USED TO STORE THE W REGISTER IN INTERRUPT HANDLERS
PULSE_LENGTH RES 1  ;LENGTH OF THE TAPE PULSE
RAM_ADDRESS_H RES 1 ;HIGH BYTE OF RAM ADDRESS
RAM_ADDRESS_L RES 1 ;LOW BYTE OF RAM ADDRESS
SDEL_COUNT RES 1    ;USED FOR SHORTDELAY
LDEL_COUNT RES 1    ;USED FOR LONGDELAY_LCD
GEN_COUNT RES 1     ;USED FOR FULLDELAY_232, HALFDELAY_232, TXDELAY_232
GEN_COUNT2 RES 1    ;SECOND COUNTER FOR NESTED LOOPS
GEN_COUNT3 RES 1    ;COUNTER FOR USE IN USER INTERFACE FUNCTIONS
GEN_COUNT4 RES 1    ;FOR USE IN USB AND BUILD_WORD SUBROUTINES
GEN_COUNT5 RES 1    ;FOR USB FUNCTIONS THAT CALL BUILD_WORD
GEN_COUNT6 RES 1    ;FOR USB FUNCTIONS
TAPE_NAME RES 8	    ;USED TO STORE THE NAME OF THE PROGRAM WHEN THE NAME BLOCK IS PARSED
TAPE_SIZE_HIGH RES 1	;HIGH BYTE OF TAPE SIZE
TAPE_SIZE_LOW RES 1	;LOW BYTE OF TAPE SIZE
BIT_COUNT RES 1	    ;KEEPS TRACK OF CURRENT BIT FOR TAPE OUT
HEX_CHAR_HIGH RES 1 ;FOR BYTE TO HEX CONVERSION
HEX_CHAR_LOW RES 1
USB_BYTES_SENT_HIGH RES 1
USB_BYTES_SENT_LOW RES 1
USB_FILE_SIZE_HIGH RES 1
USB_FILE_SIZE_LOW RES 1
USB_BYTES_READ_HIGH RES 1
USB_BYTES_READ_LOW RES 1
;USB_DRIVE_SIZE0 RES 1  ;THE DRIVE SIZE IS GIVEN IN MULTIPLES OF 512, SO THE LSB IS ALWAYS 0
USB_DRIVE_SIZE1 RES 1
USB_DRIVE_SIZE2 RES 1
USB_DRIVE_SIZE3 RES 1   ;MSB OF DRIVE SIZE
;USB_FREE_SPACE0 RES 1  ;FREE SPACE IS GIVEN IN MULTIPLES OF 512, SO THE LSB IS ALWAYS 0
USB_FREE_SPACE1 RES 1
USB_FREE_SPACE2 RES 1
USB_FREE_SPACE3 RES 1   ;MSB OF FREE SPCAE
;USB_LOGICAL_BYTES0 RES 1   ;LOGICAL BYTES ARE SPECIFIED IN MULTIPLES OF 512, SO THE LSB IS ALWAYS 0
USB_LOGICAL_BYTES1 RES 1
USB_LOGICAL_BYTES2 RES 1
USB_LOGICAL_BYTES3 RES 1    ;MSB OF LOGICAL BYTES
USB_TARGET_STATUS RES 1 ;WAIT_STATUS WILL WAIT FOR THIS STATUS
S_REG_HIGH RES 1    ;HIGH BYTE OF RANDOM WORD
S_REG_LOW RES 1 ;LOW BYTE OF RANDOM WORD
TIMEOUT_LOW RES 1 ;LSB OF TIMEOUT IN MILLISECONDS
TIMEOUT_HIGH RES 1 ;MSB OF TIMEOUT IN MILLISECONDS
DELAY_COUNTER RES 1 ;FOR DELAY MILLIS
STRING_INDEX RES 1  ;OFFSET IN SELECTED STRING
STRING_ID   RES 1   ;SELECTS A STRING
FLAG_REG RES 1  ;BITS USED AS FLAGS FOR VARIOUS SUBROUTINES

BUFS1 UDATA
BUFFER_1 RES D'80'

BUFS2 UDATA
BUFFER_2 RES D'96'

BUFS3 UDATA
BUFFER_3 RES D'96'

;FLAG REG USAGE:
;BIT0 SET IF S_REG_LOW CONTAINS VALID DATA
;BIT1 SET IF BUILD_BYTE IS WAITING FOR THE FIRST BYTE OF A TRANSMISSION (PREVENTS RESET IF TRANSMISSION FAILS)
;BIT2 SET IF TIMEOUT OCCURED WHILE WAITING FOR USB STATUS
;BIT3 SET IF FREE SPACE EXCEEDS TAPE SIZE
;BIT4 SET IF FREE SPCAE EXCEEDS 0x20000
;BIT5 UNUSED
;BIT6 UNUSED
;BIT7 UNUSED

RST CODE 0X00	;RESET VECTOR
    PAGESEL INITIALIZE
    GOTO INITIALIZE
INT CODE 0X04	;INTERRUPT VECTOR
    ;MOVWF TEMP4
    ;BCF INTCON, T0IF
    ;MOVLW B'00010000'
    ;XORWF PORTD	;TOGGLE TEST OUTPUT
    ;MOVF TEMP4, W
    ;RETFIE
    GOTO TAPE_INT

START CODE 0X05   ;START OF PROGRAM

INITIALIZE
    BANKSEL PORTA
    CLRF PORTA
    CLRF PORTB
    CLRF PORTC
    CLRF PORTD
    BSF PORTD,4
    COMF PORTA, F
    COMF PORTB, F
    COMF PORTC, F
    BANKSEL TRISA  ;SWITCH TO BANK 1
    MOVLW B'11000010'
    MOVWF TRISA	;CONFIGURE PORTA
    MOVLW B'01111011'
    MOVWF TRISB ;CONFIGURE PORTB
    MOVLW B'11010000'
    MOVWF TRISC ;CONFIGURE PORTC
    MOVLW B'00000000'
    MOVWF TRISD	;CONFIGURE PORTD
    MOVLW B'11111000'
    MOVWF TRISE	;CONFIGURE PORTE
    MOVLW B'00000000'	    ;SMP=0, CKE=0, DA=0, P=0, S=0, RW=0, UA=0, BF=0
    MOVWF SSPSTAT ;CONFIGURE SPI
    MOVLW B'00001111'	    ;PCFG=1111
    MOVWF ADCON1 ;DISABLE ANALOG INPUTS
    MOVLW B'00100110'	;CSRC=0, TX9=0, TXEN=1, SYNC=0, UNIMPLEMENTED=0, BRGH=1, TRMT=1, TX9D=0
    MOVWF TXSTA ;CONFIGURE UART
    MOVLW D'25'
    MOVWF SPBRG ;CONFIGURE BAUD RATE
    MOVLW B'11011000'	;RBPU = 1, INTEDG = 1, T0CS = 0, T0SE = 1, PSA = 1, PS2 = 0, PS1 = 0, PS0 = 0
    MOVWF OPTION_REG	;CONFIGURE TIMER
    BANKSEL SSPCON
    MOVLW B'00110000'	;WCOL=0, SSPOV=0, SSPEN=1, CKP=1, SSPM=0000
    MOVWF SSPCON ;CONFIGURE SPI
    MOVLW B'10010000'	;SPEN=1, RX9=0,SREN=0, CREN=1, ADDEN=0, FERR=0, OERR=0, RX9D=0
    MOVWF RCSTA ;CONFIGURE UART
    MOVLW B'00100000'
    MOVWF INTCON    ;ENABLE TIMER 0 INTERRUPT
    CLRF FLAG_REG
    CLRF S_REG_HIGH
    CLRF S_REG_LOW
    MOVLW D'100'
    MOVWF DELAY_COUNTER
    CALL DELAY_MILLIS   ;100 MS DELAY AT STARTUP
    CALL RAM_CONFIG
    CLRF RAM_ADDRESS_H
    CLRF RAM_ADDRESS_L
    MOVLW H'55'
    MOVWF DREG
    CALL RAM_WRITE
    CALL FUNCTIONSET_LCD    ;INITIALIZE DISPLAY
    CALL DISPLAYON  ;POWER ON THE DISPLAY
    CALL CLEARDISPLAY	;CLEAR THE DISPLAY
    CALL SETHOME_LCD	;SET CURSOR TO THE START OF LINE 1
    GOTO MAIN	;DO THE THING

MAIN
    CALL UART_READ
    CALL UART_SEND
    MOVF DREG, W
    MOVWF TEMP1	;SAVE DATA
    XORLW H'F1'	;IS F1?
    BTFSC STATUS, Z ;CHECK ZERO FLAG
    GOTO LISTEN	    ;LISTEN TO TAPE AND PUT DATA IN MEMORY, THEN SEND DATA TO UART
    MOVF TEMP1, W
    XORLW H'F2'	;IS F2?
    BTFSC STATUS, Z ;CHECK ZERO FLAG
    GOTO SEND_TAPE  ;GENERATE TAPE AUDIO FROM DATA IN MEMORY
    MOVF TEMP1, W
    XORLW H'F3'	;IS F3?
    BTFSC STATUS, Z ;CHECK ZERO FLAG
    GOTO CMD_SETHOME
    MOVF TEMP1, W
    XORLW H'F4'	;IS F4?
    BTFSC STATUS, Z
    GOTO CMD_LINE2
    MOVF TEMP1, W
    XORLW H'F5'
    BTFSC STATUS, Z
    GOTO CMD_LCD_CLEAR1
    MOVF TEMP1, W
    XORLW H'F6'
    BTFSC STATUS, Z
    GOTO CMD_LCD_CLEAR2
    MOVF TEMP1, W
    XORLW H'F7'
    BTFSC STATUS, Z
    GOTO CMD_CLEARDISPLAY
    MOVF TEMP1, W
    XORLW H'F8'
    BTFSC STATUS, Z
    GOTO CMD_PRINT_NAME
    MOVF TEMP1, W
    XORLW H'F9'
    BTFSC STATUS, Z
    GOTO CMD_MEM_DUMP
    MOVF TEMP1, W
    XORLW H'FA'
    BTFSC STATUS, Z
    GOTO CMD_PRINT_HOME
    MOVF TEMP1, W
    XORLW H'FB'	;IS COMMAND 0xFB?
    BTFSC STATUS, Z
    GOTO CMD_MEM_CLEAR
    GOTO MAIN
LISTEN
    CALL TAPE_IN
    MOVLW H'FF'
    MOVWF RAM_ADDRESS_H
    MOVWF RAM_ADDRESS_L
    DECF TAPE_SIZE_LOW, F
    INCFSZ TAPE_SIZE_LOW, W
    GOTO LISTEN2
    DECF TAPE_SIZE_HIGH, F
LISTEN2
    CALL RAM_READ_AUTO
    CALL UART_SEND
    MOVF RAM_ADDRESS_H, W
    XORWF TAPE_SIZE_HIGH, W
    BTFSS STATUS, Z
    GOTO LISTEN2
    MOVF RAM_ADDRESS_L, W
    XORWF TAPE_SIZE_LOW, W
    BTFSS STATUS, Z
    GOTO LISTEN2
    INCFSZ TAPE_SIZE_LOW, F    ;INCREMENT LOW ADDRESS
    DECF TAPE_SIZE_HIGH, F
    INCF TAPE_SIZE_HIGH, F	;IF LOW ADDRESS IS ZERO INCREMENT THE HIGH ADDRESS TOO
    GOTO MAIN
SEND_TAPE
    CALL TAPE_OUT
    GOTO MAIN
CMD_SETHOME
    CALL SETHOME_LCD
    GOTO MAIN
CMD_LINE2
    CALL LINE2_LCD
    GOTO MAIN
CMD_LCD_CLEAR1
    CALL LCD_CLEAR1
    GOTO MAIN
CMD_LCD_CLEAR2
    CALL LCD_CLEAR2
    GOTO MAIN
CMD_CLEARDISPLAY
    CALL CLEARDISPLAY
    GOTO MAIN
CMD_PRINT_NAME
    CALL PRINT_NAME
    GOTO MAIN
CMD_MEM_DUMP
    CALL MEM_DUMP
    GOTO MAIN
CMD_PRINT_HOME
    CLRF STRING_ID
    CALL PRINT_STRING_LCD
    GOTO MAIN
CMD_MEM_CLEAR
    CALL MEM_CLEAR
    GOTO MAIN

MEM_CLEAR
    CLRF RAM_ADDRESS_L
    CLRF RAM_ADDRESS_H
    COMF RAM_ADDRESS_L, F
    COMF RAM_ADDRESS_H, F
    CLRF DREG
    COMF DREG, F
MEM_CLEAR_LOOP
    BSF PORTD, 4
    CALL RAM_WRITE_AUTO
    BCF PORTD, 4    ;PORTD 4 IS A DEBUG OUTPUT TO MEASURE THE DURATION OF RAM_WRITE
    MOVF RAM_ADDRESS_L, W
    XORLW H'FF'
    BTFSS STATUS, Z
    GOTO MEM_CLEAR_LOOP
    MOVF RAM_ADDRESS_H, W
    XORLW H'FF'
    BTFSS STATUS, Z
    GOTO MEM_CLEAR_LOOP
    RETURN

MEM_DUMP
    CLRF RAM_ADDRESS_L
    CLRF RAM_ADDRESS_H
    COMF RAM_ADDRESS_L, F
    COMF RAM_ADDRESS_H, F
MEM_DUMP_LOOP
    CALL RAM_READ_AUTO
    CALL UART_SEND
    MOVF RAM_ADDRESS_L, W
    XORLW H'FF'
    BTFSS STATUS, Z
    GOTO MEM_DUMP_LOOP
    MOVF RAM_ADDRESS_H, W
    XORLW H'FF'
    BTFSS STATUS, Z
    GOTO MEM_DUMP_LOOP
    RETURN

UART_READ
    BTFSS PIR1,RCIF    ;CHECK IF UART RECEIVE BUFFER IS FULL
    GOTO UART_READ  ;IF NOT WAIT UNTIL ITS FULL
    MOVF RCREG, W   ;COPY DATA TO W
    MOVWF DREG	    ;COPY DATA TO DREG
    RETURN

UART_SEND
    BTFSS PIR1,TXIF    ;CHECK IF UART TRANSMIT BUFFER IS EMPTY
    GOTO UART_SEND  ;IF NOT WAIT UNTIL IT IS
    MOVF DREG, W    ;COPY DATA TO W
    MOVWF TXREG	    ;COPY DATA TO TXREG
    RETURN

RAM_READ_AUTO
    INCFSZ RAM_ADDRESS_L, F    ;INCREMENT LOW ADDRESS
    DECF RAM_ADDRESS_H, F
    INCF RAM_ADDRESS_H, F	;IF LOW ADDRESS IS ZERO INCREMENT THE HIGH ADDRESS TOO
RAM_READ
    BCF PORTB, 7    ;CHIP ENABLE
    MOVLW H'03'	;PUT WRITE COMMAND IN W
    MOVWF SSPBUF    ;SEND COMMAND
    MOVF RAM_ADDRESS_H, W   ;COPY ADDRESS TO W
    BANKSEL SSPSTAT
RAM_WAIT_AH
    BTFSS SSPSTAT, BF	;IS THE TRANSMISSION READY
    GOTO RAM_WAIT_AH	;IF NOT WAIT UNTIL IT IS
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND ADDRESS HIGH BYTE
    MOVF RAM_ADDRESS_L, W   ;COPY ADDRESS TO W
    BANKSEL SSPSTAT
RAM_WAIT_AL
    BTFSS SSPSTAT, BF
    GOTO RAM_WAIT_AL
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND ADDRESS LOW BYTE
    BANKSEL SSPSTAT
RAM_WAIT_D
    BTFSS SSPSTAT, BF
    GOTO RAM_WAIT_D
    BANKSEL SSPBUF
    CLRF SSPBUF
    BANKSEL SSPSTAT
RAM_WAIT_R
    BTFSS SSPSTAT, BF
    GOTO RAM_WAIT_R
    BANKSEL SSPBUF
    MOVF SSPBUF, W  ;COPY DATA TO W
    MOVWF DREG	;PUT DATA IN DREG
    BSF PORTB, 7
    RETURN

RAM_WRITE_AUTO
    INCFSZ RAM_ADDRESS_L, F    ;INCREMENT LOW ADDRESS
    DECF RAM_ADDRESS_H, F
    INCF RAM_ADDRESS_H, F	;IF LOW ADDRESS IS ZERO INCREMENT THE HIGH ADDRESS TOO
RAM_WRITE
    BCF PORTB, 7    ;CHIP ENABLE
    MOVLW H'02'	;PUT WRITE COMMAND IN W
    MOVWF SSPBUF    ;SEND COMMAND
    MOVF RAM_ADDRESS_H, W   ;COPY ADDRESS TO W
    BANKSEL SSPSTAT
RAM_WRITE_AH
    BTFSS SSPSTAT, BF	;IS THE TRANSMISSION READY
    GOTO RAM_WRITE_AH	;IF NOT WAIT UNTIL IT IS
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND ADDRESS HIGH BYTE
    MOVF RAM_ADDRESS_L, W   ;COPY ADDRESS TO W
    BANKSEL SSPSTAT
RAM_WRITE_AL
    BTFSS SSPSTAT, BF
    GOTO RAM_WRITE_AL
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND ADDRESS LOW BYTE
    MOVF DREG, W    ;COPY DATA TO W
    BANKSEL SSPSTAT
RAM_WRITE_D
    BTFSS SSPSTAT, BF
    GOTO RAM_WRITE_D
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND DATA
    BANKSEL SSPSTAT
RAM_WRITE_R
    BTFSS SSPSTAT, BF
    GOTO RAM_WRITE_R
    BANKSEL SSPBUF
    MOVF SSPBUF, W  ;COPY DUMMY DATA TO W
    BSF PORTB, 7
    RETURN

RAM_CONFIG
    BCF PORTB, 7    ;CHIP ENABLE
    MOVLW H'01'	;PUT WRITE COMMAND IN W
    MOVWF SSPBUF    ;SEND COMMAND
    MOVLW H'00'	;CONFIGURE FOR BYTE MODE
    BANKSEL SSPSTAT
RAM_CONFIG_C
    BTFSS SSPSTAT, BF	;IS THE TRANSMISSION READY
    GOTO RAM_CONFIG_C	;IF NOT WAIT UNTIL IT IS
    BANKSEL SSPBUF
    MOVWF SSPBUF    ;SEND CONFIG DATA
    BANKSEL SSPSTAT
RAM_CONFIG_D
    BTFSS SSPSTAT, BF
    GOTO RAM_CONFIG_D
    BANKSEL SSPBUF
    MOVF SSPBUF, W  ;COPY DUMMY DATA TO W
    BSF PORTB, 7
    RETURN

LCD_SEND    ;SENDS DATA OR COMMAND TO LCD SHIFT REGISTER
    MOVWF TEMP3	;COPY DATA TO TEMP VARIABLE
    MOVLW H'08'
    MOVWF GEN_COUNT3	;COUNT 8 BITS
LCD_SEND_LOOP
    BTFSC TEMP3,7
    BSF PORTD,7
    BTFSS TEMP3,7
    BCF PORTD,7
    RLF TEMP3,F
    BSF PORTD,6
    NOP
    NOP
    BCF PORTD,6
    DECFSZ GEN_COUNT3,F
    GOTO LCD_SEND_LOOP
    RETURN

FUNCTIONSET_LCD
	BCF PORTA,2	;MAKE SURE THAT E STARTS LOW
        BCF PORTD,6     ;MAKE SURE DISPLAY CLOCK STARTS LOW
        BCF PORTA,3	;RS LINE TO 0 (PORT A BIT 3)
        MOVLW b'00111000'	;FUNCTION SET COMMAND
        CALL LCD_SEND
        CALL PULSE_E    ;PULSE E LINE HIGH (PORT A BIT 2)
        MOVLW D'10'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
	RETURN

DISPLAYON
        BCF PORTA,3   ;RS LINE TO 0 (PORT A BIT 3)
        MOVLW 0FH  ;DISPLAY ON/OFF AND CURSOR COMMAND
        CALL LCD_SEND
        CALL PULSE_E
        MOVLW D'10'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
	RETURN

CLEARDISPLAY
        BCF PORTA,3	;RS LINE LOW
        MOVLW 01H	;CLEAR DISPLAY COMMAND
        CALL LCD_SEND	;WRITE TO DATA LINES
        CALL PULSE_E
        MOVLW D'10'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
        RETURN

SETHOME_LCD
        BCF PORTA,3 ;RS LINE LOW
        MOVLW 03H   ;DISPLAY AND CURSOR HOME COMMAND
        CALL LCD_SEND ;WRITE TO DATA LINES
        CALL PULSE_E
        MOVLW D'5'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
        RETURN

LINE2_LCD
	CALL SETHOME_LCD
        MOVLW 28H   ;SET COUNTER TO 40
        MOVWF GEN_COUNT2
        MOVLW b'00010000'   ;CURSOR LEFT COMMAND
        CALL LCD_SEND ;WRITE COMMAND TO DATA LINES
CLLOOP40
	BCF PORTA,3	;RS LINE LOW (COMMAND MODE)
	CALL PULSE_E
        MOVLW D'2'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
        DECFSZ GEN_COUNT2, F
        GOTO CLLOOP40
        RETURN

LCD_CLEAR1
	CALL SETHOME_LCD
	MOVLW H'20' ;SPACE CHAR
	BSF PORTA,3 ;RS LINE HIGH FOR DATA
	CALL LCD_SEND	;PUT CHAR ON THE DATA LINES
	MOVLW D'20' ;COUNT 20 SPACE CHARS
	MOVWF GEN_COUNT2
LCD_CLEAR12
	CALL PULSE_E
        MOVLW D'2'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
	DECFSZ GEN_COUNT2, F
	GOTO LCD_CLEAR12
	CALL SETHOME_LCD
	RETURN

LCD_CLEAR2
	CALL LINE2_LCD
	MOVLW H'20' ;SPACE CHAR
	BSF PORTA,3 ;RS LINE HIGH FOR DATA
	CALL LCD_SEND	;PUT CHAR ON THE DATA LINES
	MOVLW D'20' ;COUNT 20 SPACE CHARS
	MOVWF GEN_COUNT2
LCD_CLEAR22
	CALL PULSE_E
        MOVLW D'2'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
	DECFSZ GEN_COUNT2, F
	GOTO LCD_CLEAR22
	CALL LINE2_LCD
	RETURN

PULSE_E
	BSF PORTA,2   ;SET E LINE HIGH
        NOP
        NOP
        NOP
        NOP
        NOP ;MODIFIED FOR 4MHZ CLOCK
        NOP
        NOP
        NOP
        BCF PORTA,2   ;SET E LINE LOW
        RETURN

PRINT_NAME
        BCF STATUS, IRP ;SET BANK 0 AND 1
	MOVLW TAPE_NAME
	MOVWF FSR
	MOVLW D'8'  ;COUNT 8 CHARS
	MOVWF GEN_COUNT2
	BSF PORTA,3 ;RS LINE HIGH FOR DATA
PN_LOOP
	MOVF INDF, W
	CALL LCD_SEND
	CALL PULSE_E
        MOVLW D'2'
        MOVWF DELAY_COUNTER
        CALL DELAY_MILLIS
	INCF FSR, F
	DECFSZ GEN_COUNT2, F
	GOTO PN_LOOP
	RETURN

PRINT_STRING_LCD
    CLRF STRING_INDEX ;START WITH ZERO OFFSET
    BSF PORTA,3 ;RS LINE HIGH FOR DATA
PSL2
    MOVLW HIGH HOME_STRING  ;HOME STRING IS ON A DIFFERENT PAGE
    MOVWF PCLATH
    CALL STRING_TABLE
    MOVWF TEMP1 ;PUT THE RETURN VALUE IN TEMP TO SET CONDITION CODES
    MOVLW HIGH MAIN
    MOVWF PCLATH    ;SET PCLATH BACK TO PAGE 0
    MOVF TEMP1, W
    BTFSC STATUS,Z  ;IF ZERO
    RETURN
    CALL LCD_SEND   ;PUT THE CHAR
    CALL PULSE_E
    MOVLW D'2'
    MOVWF DELAY_COUNTER
    CALL DELAY_MILLIS
    INCF STRING_INDEX, F ;INC OFFSET
    GOTO PSL2 ;DO IT AGAIN

PRINT_STRING_SERIAL
    CLRF STRING_INDEX ;START WITH ZERO OFFSET
PSS2
    MOVLW HIGH HOME_STRING  ;HOME STRING IS ON A DIFFERENT PAGE
    MOVWF PCLATH
    CALL STRING_TABLE
    MOVWF DREG
    MOVLW HIGH MAIN
    MOVWF PCLATH    ;SET PCLATH BACK TO PAGE 0
    MOVF DREG, F
    BTFSC STATUS,Z  ;IF ZERO
    RETURN
    CALL UART_SEND   ;PUT THE CHAR
    INCF STRING_INDEX, F ;INC OFFSET
    GOTO PSS2 ;DO IT AGAIN

TAPE_IN
    MOVLW H'FF'
    MOVWF RAM_ADDRESS_H
    MOVWF RAM_ADDRESS_L
    BSF FLAG_REG,1 ;DISSABLE RESET IF TRANSMISSION FAILS
    CALL GET_LEADER
    BCF FLAG_REG,1 ;ENABLE RESET IF TRANSMISSION FAILS
    CALL SAVE_FIRST_BLOCK
    INCFSZ RAM_ADDRESS_L, F    ;INCREMENT LOW ADDRESS
    DECF RAM_ADDRESS_H, F
    INCF RAM_ADDRESS_H, F	;IF LOW ADDRESS IS ZERO INCREMENT THE HIGH ADDRESS TOO
    MOVF RAM_ADDRESS_H, W
    MOVWF TAPE_SIZE_HIGH
    MOVF RAM_ADDRESS_L, W
    MOVWF TAPE_SIZE_LOW
    CLRF RAM_ADDRESS_H
    MOVLW H'03'
    MOVWF RAM_ADDRESS_L
    BCF STATUS, IRP ;SET BANKS 0 AND 1
    MOVLW TAPE_NAME
    MOVWF FSR
    MOVLW D'08'
    MOVWF GEN_COUNT
NAME_COPY
    CALL RAM_READ_AUTO
    MOVF DREG, W
    MOVWF INDF
    INCF FSR, F
    DECFSZ GEN_COUNT, F
    GOTO NAME_COPY
    RETURN

GET_LEADER
    MOVLW D'128'    ;LENGTH OF LEADER
    MOVWF GEN_COUNT2
LEADER_LOOP
    CALL BUILD_BYTE
    MOVF DREG,W
    XORLW H'55'
    BTFSS STATUS, Z
    GOTO GL_FIX
    DECFSZ GEN_COUNT2, F
    GOTO LEADER_LOOP
    RETURN
GL_FIX
    DECFSZ GEN_COUNT2, F
    GOTO GL_FIX2
    GOTO BUILD_PANIC
GL_FIX2
    CALL BUILD_ALIGN
    MOVF DREG,W
    XORLW H'55'
    BTFSS STATUS,Z
    GOTO BUILD_PANIC
    DECFSZ GEN_COUNT2, F
    GOTO LEADER_LOOP
    GOTO BUILD_PANIC

SAVE_FIRST_BLOCK
    CALL BUILD_BYTE
    BTFSS DREG,0    ;CHECK IF BIT 0 IS SET (IF IT IS CLEARED THERE HAS BEEN AN ALIGNMENT ERROR)
    GOTO BUILD_PANIC
    CALL RAM_WRITE_AUTO	;SAVE LEADER BYTE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE SYNC BYTE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE BLOCK TYPE BYTE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE BLOCK LENGTH
    MOVF DREG, W
    MOVWF GEN_COUNT2
FIRST_BLOCK_LOOP
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO
    DECFSZ GEN_COUNT2, F
    GOTO FIRST_BLOCK_LOOP
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE CHECKSUM
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE LEADER BYTE
    CALL GET_LEADER ;GETS THE SECOND LEADER
SAVE_BLOCKS
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE LEADER BYTE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE SYNC BYTE
    CALL BUILD_BYTE
    INCFSZ DREG, W  ;CHECK IF BLOCK IS END OF FILE
    GOTO NOT_EOF_BLOCK
    CALL RAM_WRITE_AUTO	;SAVE BLOCK TYPE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE BLOCK LENGTH
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE CHECKSUM
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE LEADER BYTE
    RETURN
NOT_EOF_BLOCK
    CALL RAM_WRITE_AUTO	;SAVE BLOCK TYPE
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE LENGTH BYTE
    MOVF DREG, W
    MOVWF GEN_COUNT2 ;COPY LENGTH TO GEN_COUNT2
BLOCK_DATA_LOOP
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO
    DECFSZ GEN_COUNT2, F
    GOTO BLOCK_DATA_LOOP
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE CHECKSUM
    CALL BUILD_BYTE
    CALL RAM_WRITE_AUTO	;SAVE LEADER BYTE
    GOTO SAVE_BLOCKS

BUILD_ALIGN ;SKIPS INITIAL WAIT IN AN ATTEMPT TO FIX ALIGNMENT. BUILD_BYTE IS THE NORMAL ENTRY POINT
    MOVLW H'08'
    MOVWF GEN_COUNT ;INITIALIZE COUNTER TO 8
    MOVF PORTB, W
    XORLW H'02' ;INVERT TAPE BIT
    MOVWF TEMP1	    ;COPY PORTB TO TEMP1
    GOTO WAIT_STOP
BUILD_BYTE
    MOVLW H'08'
    MOVWF GEN_COUNT ;INITIALIZE COUNTER TO 8
BUILD_LOOP
    MOVF PORTB, W
    MOVWF TEMP1	    ;COPY PORTB TO TEMP1
    CLRF PULSE_LENGTH
    RRF DREG, F
    BCF DREG, 7
WAIT_START
    MOVF PORTB, W
    XORWF TEMP1, W  ;COMPARE PORTB WITH PREVIOUS STATE
    MOVWF TEMP2	    ;STORE RESULT IN TEMP2
    BTFSS TEMP2, 1
    GOTO WAIT_START ;IF STATE HAS NOT CHANGED KEEP WAITING
WAIT_STOP
    CALL TAPE_DELAY
    INCF PULSE_LENGTH, F	;#1
    MOVF PULSE_LENGTH, W    ;#2
    SUBLW D'22'	    ;#3
    BTFSC STATUS, C ;CHECK IF LENGTH IS GREATER THAN 22 #4
    GOTO BUILD_NO_ERROR	;IF NOT CONTINUE NORMALLY #6
BUILD_ERROR
    BTFSS FLAG_REG, 1 ;IF ERROR IS IN FIRST BYTE TRY TO RECOVER
    GOTO BUILD_PANIC   ;IF NOT RESET TO AVOID INFINITE LOOP
    ;MOVF GEN_COUNT, W
    ;SUBLW H'08'
    ;BTFSS STATUS, Z ;CHECK IF ERROR IS IN FIRST BIT
    ;GOTO BUILD_PANIC   ; IF NOT RESET TO AVOID INFINITE LOOP
    GOTO BUILD_BYTE ;IF IT IS IN FIRST BIT OF FIRST BYTE RESTART SUBROUTINE
BUILD_NO_ERROR
    MOVF PORTB, W   ;#7
    XORWF TEMP1, W  ;#8
    MOVWF TEMP2	    ;#9
    BTFSC TEMP2, 1  ;#10
    GOTO WAIT_STOP  ;WAIT UNTIL TAPE INPUT RETURNS TO ORIGINAL STATE #12
    MOVF PULSE_LENGTH, W
    SUBLW D'08'
    BTFSC STATUS, C ;CHECK IF LENGTH IS LESS THAN 8
    GOTO BUILD_ERROR	;IF IT IS GO TO LOCAL ERROR HANDLER
    MOVLW D'15'
    SUBWF PULSE_LENGTH, F   ;SUBTRACT THRESHOLD FROM PULSE LENGTH
    BTFSC PULSE_LENGTH, 7   ;CHECK IF PULSE LENGHT IS NEGATIVE
    BSF DREG, 7		    ;IF IT IS SET BIT IN DREG
    DECFSZ GEN_COUNT, F
    GOTO BUILD_LOOP
    RETLW H'00'	;RETURN ZERO TO INDICATE SUCCESS

BUILD_PANIC ;ENABLES THE WATCHDOG TO CAUSE A RESET
    BANKSEL WDTCON
    BSF WDTCON, SWDTEN  ;ENABLE WATCHDOG
BP_HALT
    GOTO BP_HALT    ;WAIT FOR THE WATCHDOG TO DO THE THING

TAPE_DELAY
    NOP
    NOP
    NOP
    NOP
    NOP	;5 CYCLE DELAY
    RETURN

TAPE_OUT
    CLRF TEMP1
    CLRF BIT_COUNT
    MOVLW H'FF'
    MOVWF RAM_ADDRESS_H
    MOVWF RAM_ADDRESS_L	;RAM READ FUNCTION WILL AUTO INCREMENT ADDRESS, SO IT SHOULD OVERFLOW WHEN IT IS FIRST CALLED
    MOVLW H'55'
    MOVWF DREG	;TAPE LEADER VALUE
    MOVLW D'127'
    MOVWF GEN_COUNT ;128 LEADER BYTES
    CLRF TMR0
    NOP
    BCF INTCON, T0IF
    BSF INTCON, GIE	;ENABLE INTERRUPT
LEADER_OUT
    BTFSS BIT_COUNT, 2
    GOTO LEADER_OUT	;WAIT UNTIL BIT COUNT IS NOT ZERO
LEADER_WAIT
    BTFSC BIT_COUNT, 2
    GOTO LEADER_WAIT	;WAIT UNTIL BIT_COUNT IS ZERO
    DECFSZ GEN_COUNT, F
    GOTO LEADER_OUT	;LOOP UNTIL 128 LEADER BYTES HAVE BEEN SENT
    MOVLW D'22'
    MOVWF GEN_COUNT	;ONE PAST THE END OF THE NAME FILE
TAPE_NAMEBLOCK
    CALL RAM_READ_AUTO	;GET FIRST BYTE
TAPE_W1
    BTFSS BIT_COUNT, 2
    GOTO TAPE_W1    ;WAIT UNTIL BIT COUNT IS NOT ZERO
TAPE_W2
    BTFSC BIT_COUNT, 2
    GOTO TAPE_W2
    DECFSZ GEN_COUNT, F
    GOTO TAPE_NAMEBLOCK
    BCF INTCON, GIE ;STOP INTERRUPT
    CALL TAPE_PAUSE ;1/2 SECOND SILENCE
    MOVLW D'127'
    MOVWF GEN_COUNT ;128 LEADER BYTES
    CLRF TMR0
    CLRF TEMP1
    NOP
    BCF INTCON, T0IF
    BSF INTCON, GIE	;ENABLE INTERRUPT
LEADER_OUT2
    BTFSS BIT_COUNT, 2
    GOTO LEADER_OUT2	;WAIT UNTIL BIT COUNT IS NOT ZERO
LEADER_WAIT2
    BTFSC BIT_COUNT, 2
    GOTO LEADER_WAIT2	;WAIT UNTIL BIT_COUNT IS ZERO
    DECFSZ GEN_COUNT, F
    GOTO LEADER_OUT2	;LOOP UNTIL 128 LEADER BYTES HAVE BEEN SENT
TAPE_NE
    CALL RAM_READ_AUTO
TAPE_W3
    BTFSS BIT_COUNT, 2
    GOTO TAPE_W3    ;WAIT UNTIL BIT_COUNT IS NOT ZERO
TAPE_W4
    BTFSC BIT_COUNT, 2
    GOTO TAPE_W4
    MOVF TAPE_SIZE_HIGH, W
    XORWF RAM_ADDRESS_H, W
    MOVWF TEMP3	;STORE RESULT IN TEMP3
    INCF TEMP3, F   ;INCREMENT RESULT
    DECFSZ TEMP3, F
    GOTO TAPE_NE
    MOVF TAPE_SIZE_LOW, W
    XORWF RAM_ADDRESS_L, W
    MOVWF TEMP3	;STORE RESULT IN TEMP3
    INCF TEMP3, F
    DECFSZ TEMP3, F
    GOTO TAPE_NE
    BCF INTCON, GIE
    RETURN

TAPE_INT
    MOVWF TEMP4	;SAVE W REG
    BCF INTCON, T0IF
    MOVLW D'59'	;USED TO BE 58, CHANGED IT BECAUSE I ADDED THE SAVE W INSTRUCTION
    MOVWF TMR0	;PRELOAD TIMER
    BTFSC TEMP1, 0  ;IDENTIFY PHASE
    GOTO PHASE1
    BTFSC TEMP1, 1
    GOTO PHASE2
    BTFSC TEMP1, 2
    GOTO PHASE3
    BTFSC TEMP1, 3
    GOTO PHASE4
    MOVLW B'00000100'	;DEFAULT PHASE - LOAD NEW DATA AND INITIALIZE VARIABLES
    XORWF PORTB, F  ;TOGGLE TAPE OUT
    MOVF DREG, W
    MOVWF TEMP2	    ;COPY NEW DATA TO BUFFER
    CLRF BIT_COUNT
    MOVLW H'01'
    MOVWF TEMP1	;SET PHASE TO 1
    MOVF TEMP4, W   ;RESTORE W
    RETFIE
PHASE1	;TOGGLE IF BIT IS 1
	MOVLW B'00000100'	;WILL USE THIS TO TOGGLE OUTPUT
	BTFSC TEMP2, 0	;CHECK IF BIT IS 1 OR 0
	XORWF PORTB, F	;IF BIT IS 1 TOGGLE OUTPUT
	MOVLW H'02'
	MOVWF TEMP1	;SET PHASE TO 2
	MOVF TEMP4, W   ;RESTORE W
	RETFIE
PHASE2	;ALWAYS TOGGLE
	MOVLW B'00000100'
	XORWF PORTB, F	;TOGGLE OUTPUT
	BTFSC TEMP2, 0	;CHECK IF BIT IS 1 OR 0
	GOTO PHASE2_NEXT	;IF BIT IS SET THEN LOAD NEXT BIT AND RESET PHASE
	MOVLW H'04'
	MOVWF TEMP1	;SET PHASE TO 3
	MOVF TEMP4, W	;RESTORE W
	RETFIE
PHASE3	;NEVER TOGGLE
	MOVLW H'08'
	MOVWF TEMP1	;SET PHASE TO 4
	MOVF TEMP4, W
	RETFIE
PHASE4	;ALWAYS TOGGLE
	MOVLW B'00000100'
	XORWF PORTB, F	;TOGGLE OUTPUT
PHASE2_NEXT
    MOVLW H'01'
    MOVWF TEMP1	;SET PHASE TO 1
    RRF TEMP2, F	;SHIFT TO NEXT BIT
    INCF BIT_COUNT, F	;NEXT BIT COUNT
    BTFSS BIT_COUNT, 3	;CHECK IF BIT COUNT HAS REACHED 8
    GOTO PHASE_DONE	;IF NOT, RETURN
    CLRF BIT_COUNT	;CLEAR BIT COUNT
    MOVF DREG, W
    MOVWF TEMP2	;COPY NEW DATA TO BUFFER
PHASE_DONE
    MOVF TEMP4, W
    RETFIE

TAPE_PAUSE
    MOVLW D'32'
    MOVWF GEN_COUNT
TP1
    MOVLW D'54'
    MOVWF GEN_COUNT2
TP2
    MOVLW D'95'
    MOVWF LDEL_COUNT
TP3
    DECFSZ LDEL_COUNT, F
    GOTO TP3
    DECFSZ GEN_COUNT2, F
    GOTO TP2
    DECFSZ GEN_COUNT, F
    GOTO TP1
    RETURN

SPI_TRANSFER
    MOVF DREG,W
    MOVWF SSPBUF    ;SEND DATA
    BANKSEL SSPSTAT
SPI_WAIT
    BTFSS SSPSTAT, BF	;IS THE TRANSMISSION READY
    GOTO SPI_WAIT	;IF NOT WAIT UNTIL IT IS
    BANKSEL SSPBUF
    MOVF SSPBUF, W  ;COPY DATA TO W
    MOVWF DREG	;PUT DATA IN DREG
    RETURN

BYTE_TO_HEX
    PAGESEL HOME_STRING
    MOVF DREG,W
    ANDLW H'0F'
    CALL HEX_STRING
    MOVWF HEX_CHAR_LOW
    SWAPF DREG,W
    ANDLW H'0F'
    CALL HEX_STRING
    MOVWF HEX_CHAR_HIGH
    PAGESEL INITIALIZE
    RETURN

BUILD_WORD  ;GENERATES PSEUDO-RANDOM TEST DATA
    MOVLW D'16'
    MOVWF GEN_COUNT4
BUILD_WORD_LOOP
    ;GET WORD HERE
    CLRF TEMP3  ;THIS WILL CONTAIN BIT 7 OF S_REG_LOW
    BTFSC S_REG_LOW,7
    BSF TEMP3,0
    MOVF S_REG_LOW,W
    ANDLW H'01'     ;GET BIT 0
    XORWF TEMP3,F   ;TEMP3 NOW CONTAINS BIT0 AND BIT7 XORED TOGETHER
    RRF TEMP3,F
    RRF S_REG_HIGH,F
    RRF S_REG_LOW, F
    DECFSZ GEN_COUNT4,F
    GOTO BUILD_WORD_LOOP
    RETURN

GET_TEST_BYTE   ;SPLITS PSEUDO-RANDOM TEST DATA INTO SINGLE BYTES
    BTFSS FLAG_REG,0
    GOTO GTB_UPDATE
    MOVF S_REG_LOW,W
    MOVWF DREG
    BCF FLAG_REG,0
    RETURN
GTB_UPDATE
    CALL BUILD_WORD
    BSF FLAG_REG,0
    MOVF S_REG_HIGH,W
    MOVWF DREG
    RETURN

DELAY_MILLIS    ;DESIGNED FOR 4MHZ CLOCK
    MOVLW D'20'
    MOVWF LDEL_COUNT
DM_OUTER
    MOVLW D'16'
    MOVWF SDEL_COUNT
DM_INNER
    DECFSZ SDEL_COUNT,F
    GOTO DM_INNER
    DECFSZ LDEL_COUNT,F
    GOTO DM_OUTER
    DECFSZ DELAY_COUNTER,F
    GOTO DELAY_MILLIS
    RETURN

PRINT_TEST_DATA
    CLRF GEN_COUNT
PTD_OUTER
    CLRF GEN_COUNT2
PTD_INNER
    MOVF GEN_COUNT2,W
    ANDLW H'0F'
    BTFSS STATUS,Z  ;EVERY 16 WORDS PRINT A NEWLINE
    GOTO PTD_NO_NEWLINE
    MOVLW H'0A' ;NEWLINE CHAR
    MOVWF DREG
    CALL UART_SEND
PTD_NO_NEWLINE
    CALL GET_TEST_BYTE  ;GET MSB
    CALL BYTE_TO_HEX
    MOVF HEX_CHAR_HIGH,W
    MOVWF DREG
    CALL UART_SEND  ;HIGH NIBBLE HIGH BYTE
    MOVF HEX_CHAR_LOW,W
    MOVWF DREG
    CALL UART_SEND  ;LOW NIBBLE HIGH BYTE
    CALL GET_TEST_BYTE  ;GET LSB
    CALL BYTE_TO_HEX
    MOVF HEX_CHAR_HIGH,W
    MOVWF DREG
    CALL UART_SEND  ;HIGH NIBBLE LOW BYTE
    MOVF HEX_CHAR_LOW,W
    MOVWF DREG
    CALL UART_SEND  ;LOW NIBBLE LOW BYTE
    DECFSZ GEN_COUNT2,F
    GOTO PTD_INNER
    DECFSZ GEN_COUNT,F
    GOTO PTD_OUTER
    RETURN

CHECK_FREE_SPACE
    BCF FLAG_REG, 3
    BCF FLAG_REG, 4
    MOVF USB_FREE_SPACE3, F
    BTFSS STATUS, Z
    GOTO CFS2
    BSF FLAG_REG, 3
    BSF FLAG_REG, 4
    RETURN
CFS2
    MOVF USB_FREE_SPACE2, W
    SUBLW H'02'
    BTFSS STATUS, C
    GOTO CFS3
    BSF FLAG_REG, 3
    BSF FLAG_REG, 4
    RETURN
CFS3
    MOVF USB_FREE_SPACE1, W
    XORWF TAPE_SIZE_HIGH, W
    BTFSC STATUS, Z
    GOTO CFS4
    MOVF TAPE_SIZE_HIGH, W
    SUBWF USB_FREE_SPACE1, W
    BTFSC STATUS, C
    BSF FLAG_REG, 3
    RETURN
CFS4
    MOVF TAPE_SIZE_LOW, F
    BTFSC STATUS, Z
    BSF FLAG_REG, 3
    RETURN

USB_RESET_ALL
    BCF PORTD,2 ;CH376 CE LINE LOW
    MOVLW H'05' ;RESET ALL COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2 ;CH376S CE LINE HIGH
    RETURN

USB_SET_FILE_NAME
    BCF STATUS, IRP
    MOVLW TAPE_NAME ;NAME ADDRESS
    MOVWF FSR
    MOVLW H'08' ;NAME LENGTH
    MOVWF GEN_COUNT4
    BCF PORTD,2
    MOVLW H'2F' ;SET FILE NAME COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'2F' ;'\' CHAR NEEDED AT START OF NAME
    MOVWF DREG
    CALL SPI_TRANSFER
USFN_LOOP
    MOVF INDF,W
    MOVWF DREG
    CALL SPI_TRANSFER
    INCF FSR, F
    DECFSZ GEN_COUNT4,F
    GOTO USFN_LOOP
    CLRF DREG   ;NULL CHAR AT END OF NAME
    CALL SPI_TRANSFER
    BSF PORTD,2 ;CE LINE HIGH
    RETURN

USB_FILE_OPEN
    BCF PORTD,2
    MOVLW H'32' ;FILE OPEN COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_FILE_CLOSE
    BCF PORTD,2
    MOVLW H'36' ;FILE CLOSE COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'01' ;UPDATE FILE LENGTH
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_BYTE_READ
    BCF PORTD,2
    MOVLW H'3A' ;BYTE READ COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVF USB_FILE_SIZE_LOW,W
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVF USB_FILE_SIZE_HIGH,W
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_BYTE_READ_GO
    BCF PORTD,2
    MOVLW H'3B' ;BYTE READ GO COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_READ_DATA0
    BCF PORTD,2
    MOVLW H'27' ;READ DATA0 COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    CLRF DREG
    CALL SPI_TRANSFER   ;GET NUMBER OF BYTES TO READ
    MOVF DREG,W
    ADDWF USB_BYTES_READ_LOW, F
    BTFSC STATUS, C
    INCF USB_BYTES_READ_HIGH, F
    MOVWF GEN_COUNT4
URD_LOOP
    CLRF DREG
    CALL SPI_TRANSFER
    CALL RAM_WRITE_AUTO
    DECFSZ GEN_COUNT4,F
    GOTO URD_LOOP
    BSF PORTD,2
    RETURN

USB_GET_FILE_SIZE
    BCF PORTD,2
    MOVLW H'0C' ;GET FILE SIZE COMMAND
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'68' ;COMMAND DATA
    MOVWF DREG
    CALL SPI_TRANSFER
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG,W
    MOVWF USB_FILE_SIZE_LOW
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG,W
    MOVWF USB_FILE_SIZE_HIGH
    CLRF DREG
    CALL SPI_TRANSFER
    CLRF DREG
    CALL SPI_TRANSFER   ;DISCARD UPPER BYTES OF FILE SIZE
    BSF PORTD,2
    RETURN

USB_CHECK_EXISTS
    BCF PORTD,2
    MOVF DREG,W
    MOVWF TEMP4
    MOVLW H'06'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND CHECK_EXISTS COMMAND
    MOVF TEMP4,W
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND TEST DATA
    CLRF DREG
    CALL SPI_TRANSFER   ;GET RESULT
    BSF PORTD,2
    RETURN

USB_FILE_CREATE
    BCF PORTD,2
    MOVLW H'34'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_BYTE_WRITE
    BCF PORTD,2
    MOVLW H'3C'
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVF USB_FILE_SIZE_LOW, W
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVF USB_FILE_SIZE_HIGH, W
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_BYTE_WR_GO
    BCF PORTD,2
    MOVLW H'3D'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_GET_STATUS
    BCF PORTD,2
    MOVLW H'22'
    MOVWF DREG
    CALL SPI_TRANSFER
    CLRF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_DISK_MOUNT
    BCF PORTD,2
    MOVLW H'31'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_DISK_CONNECT
    BCF PORTD,2
    MOVLW H'30'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_SET_MODE_5
    BCF PORTD,2
    MOVLW H'15'
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'05'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_SET_MODE_6
    BCF PORTD,2
    MOVLW H'15'
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'06'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_SET_MODE_7
    BCF PORTD,2
    MOVLW H'15'
    MOVWF DREG
    CALL SPI_TRANSFER
    MOVLW H'07'
    MOVWF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_GET_VERSION
    BCF PORTD,2
    MOVLW H'01'
    MOVWF DREG
    CALL SPI_TRANSFER
    CLRF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    RETURN

USB_WAIT_STATUS
    INCF TIMEOUT_HIGH, F
    INCF TIMEOUT_LOW, F
UWS_LOOP
    MOVLW H'01'
    MOVWF DELAY_COUNTER
    CALL DELAY_MILLIS   ;DELAY 1 MILLISECOND
    CALL USB_GET_STATUS
    MOVF USB_TARGET_STATUS, W
    XORWF DREG, F
    BTFSC STATUS, Z
    RETURN
    DECFSZ TIMEOUT_LOW, F
    GOTO UWS_LOOP
    DECFSZ TIMEOUT_HIGH, F
    GOTO UWS_LOOP
    BSF FLAG_REG, 2    ;SET FLAG TO INDICATE A TIMEOUT
    RETURN

USB_DISK_CAPACITY
    BCF PORTD,2
    MOVLW H'3E'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND DISK CAPACITY COMMAND
    BSF PORTD,2
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS ;SET TARGET STATUS TO 14 (DEVICE READY)
    CLRF TIMEOUT_HIGH
    MOVLW H'10'
    MOVWF TIMEOUT_LOW   ;SET TIMEOUT TO 16 MILLISECONDS
    CALL USB_WAIT_STATUS
    BCF PORTD,2
    MOVLW H'27'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND READ DATA0 COMMAND
    CLRF DREG
    CALL SPI_TRANSFER   ;GET NUMBER OF BYTES TO READ (ALWAYS 4)
    CLRF DREG
    CALL SPI_TRANSFER   ;GET LSB OF DISK SIZE
;THE DISK SIZE IS GIVEN IN SECTORS, SO TO GET THE NUMBER OF BYTES WE MULTIPLY BY 512 WHICH IS THE SAME AS SHIFTING BY 9
;THIS MEANS THE LSB IS ALWAYS ZERO AND THERE IS NO NEED TO HAVE A REGISTER FOR IT.
;INSTEAD WE PUT THE LSB IN USB_DRIVE_SIZE1 WHICH CORRESPONDS TO SHIFTING BY 8.
    MOVF DREG, W
    MOVWF USB_DRIVE_SIZE1
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_DRIVE_SIZE2
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_DRIVE_SIZE3
    CLRF DREG
    CALL SPI_TRANSFER
    BSF PORTD,2
    BCF STATUS, C   ;CLEAR CARRY FLAG
    RLF USB_DRIVE_SIZE1, F
    RLF USB_DRIVE_SIZE2, F
    RLF USB_DRIVE_SIZE3, F
    RETURN

USB_DISK_QUERY
    BCF PORTD,2
    MOVLW H'3E'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND DISK CAPACITY COMMAND
    BSF PORTD,2
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS ;SET TARGET STATUS TO 14 (DEVICE READY)
    CLRF TIMEOUT_HIGH
    MOVLW H'10'
    MOVWF TIMEOUT_LOW   ;SET TIMEOUT TO 16 MILLISECONDS
    CALL USB_WAIT_STATUS
    BCF PORTD,2
    MOVLW H'27'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND READ DATA0 COMMAND
    CLRF DREG
    CALL SPI_TRANSFER   ;GET NUMBER OF BYTES TO READ (ALWAYS 8)
    CLRF DREG
    CALL SPI_TRANSFER   ;GET LSB OF LOGICAL BYTES
    MOVF DREG, W
    MOVWF USB_LOGICAL_BYTES1
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_LOGICAL_BYTES2
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_LOGICAL_BYTES3
    CLRF DREG
    CALL SPI_TRANSFER   ;DISCARD MSB OF LOGICAL BYTES
    CLRF DREG
    CALL SPI_TRANSFER   ;GET LSB OF FREE SPACE
    MOVF DREG, W
    MOVWF USB_FREE_SPACE1
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_FREE_SPACE2
    CLRF DREG
    CALL SPI_TRANSFER
    MOVF DREG, W
    MOVWF USB_FREE_SPACE3
    CLRF DREG
    CALL SPI_TRANSFER   ;DISCARD MSB OF FREE SPACE
    BSF PORTD,2
    BCF STATUS, C
    RLF USB_LOGICAL_BYTES1, F
    RLF USB_LOGICAL_BYTES2, F
    RLF USB_LOGICAL_BYTES3, F
    BCF STATUS, C
    RLF USB_FREE_SPACE1, F
    RLF USB_FREE_SPACE2, F
    RLF USB_FREE_SPACE3, F
    RETURN

USB_WRITE_TEST_DATA
    CLRF S_REG_LOW
    CLRF S_REG_HIGH
    BCF FLAG_REG, 0 ;INITIALIZE PSUEDO-RANDOM DATA GENERATOR
    CALL USB_FILE_CREATE
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH  ;SET TIMEOUT TO 3 SECONDS
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS ;SET TARGET STATUS TO 0x14
    CALL USB_WAIT_STATUS
    MOVLW H'04'
    MOVWF GEN_COUNT6
UWTD_L4
    CLRF USB_BYTES_SENT_HIGH
    CLRF USB_BYTES_SENT_LOW
    MOVLW H'80'
    MOVWF USB_FILE_SIZE_HIGH
    CLRF USB_FILE_SIZE_LOW
    CALL USB_BYTE_WRITE
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
UWTD_ND_LOOP
    BCF PORTD,2
    MOVLW H'2D'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND WR_REQ_DATA
    CLRF DREG
    CALL SPI_TRANSFER   ;GET NUMBER OF BYTES TO SEND
    MOVF DREG, W
    MOVWF GEN_COUNT5
UWTD_WR_LOOP
    CALL GET_TEST_BYTE
    CALL SPI_TRANSFER
    INCFSZ USB_BYTES_SENT_LOW, F
    DECF USB_BYTES_SENT_HIGH, F
    INCF USB_BYTES_SENT_HIGH, F
    MOVF USB_BYTES_SENT_HIGH, W
    XORWF USB_FILE_SIZE_HIGH, W
    BTFSS STATUS, Z
    GOTO UWTD_NB
    MOVF USB_BYTES_SENT_LOW, W
    XORWF USB_FILE_SIZE_LOW, W
    BTFSC STATUS, Z
    GOTO UWTD_BREAK
UWTD_NB
    DECFSZ GEN_COUNT5, F
    GOTO UWTD_WR_LOOP
UWTD_BREAK
    BSF PORTD,2
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    MOVF USB_BYTES_SENT_HIGH, W
    XORWF USB_FILE_SIZE_HIGH, W
    BTFSS STATUS, Z
    GOTO UWTD_NE
    MOVF USB_BYTES_SENT_LOW, W
    XORWF USB_FILE_SIZE_LOW, W
    BTFSC STATUS, Z
    GOTO UWTD_EQUAL
UWTD_NE
    CALL USB_BYTE_WR_GO
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    GOTO UWTD_ND_LOOP
UWTD_EQUAL
    CALL USB_BYTE_WR_GO
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    DECFSZ GEN_COUNT6, F
    GOTO UWTD_L4
    CALL USB_FILE_CLOSE
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    RETURN

USB_FILE_WRITE
    CALL USB_SET_FILE_NAME
    MOVLW H'10'
    MOVWF TIMEOUT_LOW
    CLRF TIMEOUT_HIGH
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    CALL USB_FILE_CREATE
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH  ;SET TIMEOUT TO 3 SECONDS
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS ;SET TARGET STATUS TO 0x14
    CALL USB_WAIT_STATUS
    CLRF USB_BYTES_SENT_HIGH
    CLRF USB_BYTES_SENT_LOW
    MOVF TAPE_SIZE_HIGH, W
    MOVWF USB_FILE_SIZE_HIGH
    MOVF TAPE_SIZE_LOW, W
    MOVWF USB_FILE_SIZE_LOW
    CALL USB_BYTE_WRITE
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
UFW_ND_LOOP
    CALL BUFF_INIT
    MOVF USB_BYTES_SENT_LOW, W
    MOVWF RAM_ADDRESS_L
    MOVF USB_BYTES_SENT_HIGH, W
    MOVWF RAM_ADDRESS_H
    DECF RAM_ADDRESS_L, F
    BTFSS STATUS, C
    DECF RAM_ADDRESS_H, F
    CALL BUFF_FILL
    BCF PORTD,2
    MOVLW H'2D'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND WR_REQ_DATA
    CLRF DREG
    CALL SPI_TRANSFER   ;GET NUMBER OF BYTES TO SEND
    MOVF DREG, W
    MOVWF GEN_COUNT5
UFW_WR_LOOP
    CALL BUFF_READ_AUTO
    CALL SPI_TRANSFER
    INCFSZ USB_BYTES_SENT_LOW, F
    DECF USB_BYTES_SENT_HIGH, F
    INCF USB_BYTES_SENT_HIGH, F
    MOVF USB_BYTES_SENT_HIGH, W
    XORWF USB_FILE_SIZE_HIGH, W
    BTFSS STATUS, Z
    GOTO UFW_NB
    MOVF USB_BYTES_SENT_LOW, W
    XORWF USB_FILE_SIZE_LOW, W
    BTFSC STATUS, Z
    GOTO UFW_BREAK
UFW_NB
    DECFSZ GEN_COUNT5, F
    GOTO UFW_WR_LOOP
UFW_BREAK
    BSF PORTD,2
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    MOVF USB_BYTES_SENT_HIGH, W
    XORWF USB_FILE_SIZE_HIGH, W
    BTFSS STATUS, Z
    GOTO UFW_NE
    MOVF USB_BYTES_SENT_LOW, W
    XORWF USB_FILE_SIZE_LOW, W
    BTFSC STATUS, Z
    GOTO UFW_EQUAL
UFW_NE
    CALL USB_BYTE_WR_GO
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'1E'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    GOTO UFW_ND_LOOP
UFW_EQUAL
    CALL USB_BYTE_WR_GO
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    CALL USB_FILE_CLOSE
    MOVLW H'0B'
    MOVWF TIMEOUT_HIGH
    MOVLW H'B8'
    MOVWF TIMEOUT_LOW
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    RETURN

USB_FILE_READ
    MOVLW H'FF'
    MOVWF RAM_ADDRESS_H
    MOVWF RAM_ADDRESS_L ;RAM ADDRESS WILL OVERFLOW BEFORE FIRST WRITE
    CALL USB_BYTE_READ
    CLRF TIMEOUT_HIGH
    MOVLW H'80'
    MOVWF TIMEOUT_LOW
    MOVLW H'1D'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    BTFSS FLAG_REG, 2   ;CHECK TIMEOUT FLAG
    GOTO TIMEOUT_ERROR
UFR_LOOP
    CALL USB_READ_DATA0
    MOVLW H'01'
    MOVWF DELAY_COUNTER
    CALL DELAY_MILLIS
    MOVF USB_FILE_SIZE_LOW, W
    XORWF USB_BYTES_READ_LOW, W
    BTFSS STATUS, Z
    GOTO UFR_GO
    MOVF USB_FILE_SIZE_HIGH, W
    XORWF USB_BYTES_READ_HIGH, W
    BTFSC STATUS, Z
    GOTO UFR_DONE
UFR_GO
    CALL USB_BYTE_READ_GO
    CLRF TIMEOUT_HIGH
    MOVLW H'FF'
    MOVWF TIMEOUT_LOW
    MOVLW H'1D'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    GOTO UFR_LOOP
UFR_DONE
    MOVF USB_FILE_SIZE_LOW, W
    MOVWF TAPE_SIZE_LOW
    MOVF USB_FILE_SIZE_HIGH, W
    MOVWF TAPE_SIZE_HIGH
    BCF PORTD,2
    MOVLW H'36'
    MOVWF DREG
    CALL SPI_TRANSFER   ;SEND FILE CLOSE COMMAND
    CLRF DREG
    CALL SPI_TRANSFER   ;FILE CLOSE PARAMETER IS 0 (DO NOT UPDATE FILE SIZE)
    BSF PORTD,2
    CLRF TIMEOUT_HIGH
    MOVLW H'80'
    MOVWF TIMEOUT_LOW
    MOVLW H'14'
    MOVWF USB_TARGET_STATUS
    CALL USB_WAIT_STATUS
    RETURN

TIMEOUT_ERROR
    MOVF DREG, W
    MOVWF TEMP2
    CLRF GEN_COUNT2
    MOVLW H'04'
    MOVWF STRING_ID
    CALL PRINT_STRING_SERIAL
    MOVLW H'20' ;SPACE CHAR
    MOVWF DREG
    CALL UART_SEND
    MOVF USB_TARGET_STATUS, W
    MOVWF DREG
    CALL BYTE_TO_HEX
    MOVF HEX_CHAR_HIGH, W
    MOVWF DREG
    CALL UART_SEND
    MOVF HEX_CHAR_LOW, W
    MOVWF DREG
    CALL UART_SEND
    MOVLW H'0A' ;NEW LINE CHAR
    MOVWF DREG
    CALL UART_SEND
    MOVF TEMP2, W
    MOVWF DREG
    RETURN

BUFF_INIT
    BCF STATUS, IRP    ;SWITCH TO BANKS 0 AND 1
    MOVLW H'A0' ;SWITCH TO BANK 1
    MOVWF FSR
    RETURN

BUFF_FILL
    CLRF GEN_COUNT6
BUFF_FILL_LOOP
    CALL RAM_READ_AUTO
    CALL BUFF_WRITE_AUTO
    DECFSZ GEN_COUNT6, F
    GOTO BUFF_FILL_LOOP
    RETURN

BUFF_WRITE_AUTO
    MOVF DREG, W
    MOVWF INDF
    GOTO BUFR_INC
BUFF_READ_AUTO
    MOVF INDF, W
    MOVWF DREG
BUFR_INC
    INCF FSR, F
    MOVF FSR, W
    ANDLW H'7F'
    XORLW H'70'
    BTFSS STATUS, Z
    RETURN
    BTFSC FSR, 7
    GOTO BUFR_ODD
BUFR_EVEN
    BTFSC STATUS, IRP
    GOTO BUFR_B2
BUFR_B0
    GOTO BUILD_PANIC ;THIS FUNCTION SHOULD NEVER READ BANK 0!
BUFR_B2
    MOVLW H'90' ;IRP ALREADY SET, SWITCH TO ODD BANKS
    MOVWF FSR
    RETURN
BUFR_ODD
    BTFSC STATUS, IRP
    GOTO BUFR_B3
BUFR_B1
    BSF STATUS, IRP ;SWITCH TO BANKS 2 AND 3
    MOVLW H'10' ;SWITCH TO EVEN BANKS
    MOVWF FSR
    RETURN
BUFR_B3
    BCF STATUS, IRP ;SWITCH TO BANKS 0 AND 1
    MOVLW H'A0' ;SWITCH TO BANK 1
    MOVWF FSR
    RETURN

STRINGS CODE H'0800' ;STRINGS AND TABLES
STRING_TABLE
    MOVF STRING_ID, W
    ADDWF PCL, F
    GOTO HOME_STRING    ;ID0
    GOTO LOAD_STRING    ;ID1
    GOTO SAVE_STRING    ;ID2
    GOTO SEND_STRING    ;ID3
    GOTO TIMEOUT_STRING ;ID4
    GOTO NEXT_STRING    ;ID5
    GOTO BACK_STRING    ;ID6

HOME_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL,F
    RETLW 'T'
    RETLW 'A'
    RETLW 'P'
    RETLW 'E'
    RETLW ' '
    RETLW 'R'
    RETLW 'E'
    RETLW 'A'
    RETLW 'D'
    RETLW 'Y'
    RETLW '.'
    RETLW H'00'

LOAD_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL,F
    RETLW 'L'
    RETLW 'O'
    RETLW 'A'
    RETLW 'D'
    RETLW H'00'

SAVE_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL,F
    RETLW 'S'
    RETLW 'A'
    RETLW 'V'
    RETLW 'E'
    RETLW H'00'

SEND_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL, F
    RETLW 'S'
    RETLW 'E'
    RETLW 'N'
    RETLW 'D'
    RETLW H'00'

TIMEOUT_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL, F
    RETLW 'T'
    RETLW 'I'
    RETLW 'M'
    RETLW 'E'
    RETLW 'O'
    RETLW 'U'
    RETLW 'T'
    RETLW ':'
    RETLW H'00'

NEXT_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL,F
    RETLW 'N'
    RETLW 'E'
    RETLW 'X'
    RETLW 'T'
    RETLW H'00'

BACK_STRING
    MOVF STRING_INDEX, W
    ADDWF PCL,F
    RETLW 'B'
    RETLW 'A'
    RETLW 'C'
    RETLW 'K'
    RETLW H'00'

HEX_STRING
    ADDWF PCL,F
    RETLW '0'
    RETLW '1'
    RETLW '2'
    RETLW '3'
    RETLW '4'
    RETLW '5'
    RETLW '6'
    RETLW '7'
    RETLW '8'
    RETLW '9'
    RETLW 'A'
    RETLW 'B'
    RETLW 'C'
    RETLW 'D'
    RETLW 'E'
    RETLW 'F'

STRINGS2 CODE H'0900'

SEND_232
    BCF PORTC,0 ;SEND STARTING BIT
    NOP
    CALL FULLDELAY_232
    BTFSC DREG,0 ;TEST FIRST BIT
    BSF PORTC,0 ;IF SET IN REGISTER SET TX LINE
    BTFSS DREG,0 ;TEST FIRST BIT
    BCF PORTC,0 ;IF CLEAR IN REGISTER CLEAR TX LINE
    CALL TXDELAY_232
    BTFSC DREG,1
    BSF PORTC,0
    BTFSS DREG,1
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,2
    BSF PORTC,0
    BTFSS DREG,2
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,3
    BSF PORTC,0
    BTFSS DREG,3
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,4
    BSF PORTC,0
    BTFSS DREG,4
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,5
    BSF PORTC,0
    BTFSS DREG,5
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,6
    BSF PORTC,0
    BTFSS DREG,6
    BCF PORTC,0
    CALL TXDELAY_232
    BTFSC DREG,7
    BSF PORTC,0
    BTFSS DREG,7
    BCF PORTC,0
    CALL TXDELAY_232
    BSF PORTC,0 ;SEND STOP BIT
    CALL FULLDELAY_232
    RETURN

RECEIVE     CLRF DREG    ;CLEAR REGISTER WHERE MESSAGE WILL BE STORED
WAIT_232    BTFSC PORTC,1
            GOTO WAIT_232
            CALL HALFDELAY_232
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK FIRST BIT
            BSF DREG,0
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 1
            BSF DREG,1
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT2
            BSF DREG,2
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 3
            BSF DREG,3
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 4
            BSF DREG,4
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 5
            BSF DREG,5
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 6
            BSF DREG,6
            CALL FULLDELAY_232
            BTFSC PORTC,1   ;CHECK BIT 7
            BSF DREG,7
            CALL HALFDELAY_232  ;TO PREVENT FALSE TRIGGER
            RETURN

FULLDELAY_232   ;DESIGNED FOR 4MHZ CLOCK AND 2400 BAUD RATE
            MOVLW 52H
            MOVWF GEN_COUNT
FULLDELAY_2322
            NOP
            NOP
            DECFSZ GEN_COUNT,1
            GOTO FULLDELAY_2322
            RETURN
HALFDELAY_232   ;DESIGNED FOR 4MHZ CLOCK AND 2400 BAUD RATE
            MOVLW 1DH
            MOVWF GEN_COUNT
HALFDELAY_2322
            NOP
            NOP
            NOP
            NOP
            DECFSZ GEN_COUNT,1
            GOTO HALFDELAY_2322
            RETURN

TXDELAY_232 MOVLW 66H
            MOVWF 24H
TXDELAY_2322
            NOP ;DESIGNED FOR 4MHz CLOCK AND 2400 BAUD RATE
            DECFSZ 24H,1
            GOTO TXDELAY_2322
            RETURN

INT_TEST_START
    CLRF TMR0
    NOP
    BCF INTCON, T0IF
    BSF INTCON, GIE
    RETURN

INT_TEST_STOP
    BCF INTCON, GIE
    RETURN

    END
